---
title: OSTEP 28 Locks
author: Seungil Kim
description: 여러가지 Lock 기법에 대해 알아보자
postSlug: OSTEP 28 Locks
featured: false
tags:
  - cs
  - os
pubDatetime: 2023-09-11T04:53:55+09:00
---
# OSTEP 28 Locks

여러 개의 명령어들을 **atomic**하게 실행하고 싶지만 단일 프로세스의 인터럽트로 인해 그렇게 할 수 없었다. 이 문제를 **lock**을 통해 직접적으로 다뤄보자. 프로그래머는 소스 코드의 임계 영역을 lock으로 둘러, 그 임계 영역이 마치 하나의 원자 단위 명령어인 것 처럼 실행되도록 한다.

## 1. 락: 기본 개념

```c
balance = balance + 1;
```

다음과 같은 임계 영역이 있다고 하자.

락으로 임계 영역을 다음과 같이 감쌌다.

```c
lock_t mutex; // 전역 변수로 선언된 락
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

락은 하나의 변수이므로, 락을 사용하기 위해 먼저 선언해야 한다. 이 **락 변수**는 사용 가능 상태, 즉 어느 쓰레드도 락을 가지고 있지 않거나, 사용 중, 즉 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태이다.

`lock()`과 `unlock()`의 의미는 간단하다. `lock()`을 호출하여 락 획득을 시도한다. 만약 어떤 쓰레드도 락을 가지고 있지 않다면 그 쓰레드는 락을 획득하여 임계 영역으로 진입한다. 이렇게 진입한 쓰레드를 락 소유자 (owner) 라고 부른다. 만약 다른 쓰레드가 `lock()`을 호출한다면, 사용 중인 동안에는 `lock()` 함수가 리턴하지 않는다. 

락 소유자가 `unlock()`을 호출한다면 락은 이제 다시 사용 가능한 상태가 된다. 어떤 쓰레드도 이 락을 대기하고 있지 않다면 (어떤 쓰레드도 `lock()`을 호출하여 멈춰 있던 상태가 아니라면) 락의 상태는 사용 가능으로 유지된다.

락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공한다. **쓰레드에 대한 제어권**을 일부 받을 수 있다. 이를 통해 프로그래머는 그 코드 내에서 **하나의 쓰레드만 동작**하도록 보장한다. 혼란스런 실행 순서에 어느 정도 질서를 부여할 수 있는 것이다.

## 2. Pthread 락

쓰레드 간 상호 배제 (mutual exclusion) 기능을 제공하기 때문에 POSIX 라이브러리는 락을 **mutex** 라고 부른다. 상호 배제는 **한 쓰레드**가 임계 영역 내에 있다면, 이 쓰레드의 동작이 끝날 때까지 다른 쓰레드가 임계 영역에 들어올 수 없도록 제한한다고 해서 붙여진 이름이다.

> 래퍼를 사용하여 락과 언락시에 에러를 확인하도록 함

```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

Pthread_mutex_lock(&lock); // pthread_mutex_lock()을 위한 래퍼.
balance = balance + 1;
Pthread_mutex_unlock(&lock);
```

POSIX 방식은 변수명을 지정하여 락과 언락 함수에 전달한다. 다른 변수를 보호하기 위해 다른 락을 사용할수도 있기 때문이다. 이를 통해 여러가지 방식으로 락을 구현할 수 있다.

### 세밀한 락과 거친 락 전략

#### 거친 락 (Coarse-Grained Locking)

- 하나의 락이 큰 임계 영역을 제어함.
- 쉽게 구현할 수 있지만, 병렬성이 제한됨.

#### 세밀한 락 (Fine-Grained Locking)

- 여러 락이 서로 다른 데이터나 자료구조를 보호함.
- 한 번에 여러 쓰레드가 서로 다른 락으로 보호된 코드 내에 진입 가능.
- 병렬성은 향상되지만, 데드락 등의 복잡한 이슈에 대처해야 함.

## 3. 락 구현

이번 장에서 어떻게 락을 만들어야 하는지, 어떤 종류의 하드웨어 지원이 필요한지, 운영체제는 무엇을 지원해야 하는지에 대해 다룰 것이다.

> 효율적인 락은 어떻게 만들어야 하는가? 효율적인 락은 낮은 비용으로 상호 배제 기법을 제공하고 다음에 다룰 몇 가지 속성들을 추가로 가져야 한다. 어떤 하드웨어 지원이 필요한가? 어떤 운영체제 지원이 필요한가?

## 4. 락의 평가

### 상호 배제 (mutual exclusion)
- 가장 기본 역할.
- 임계 영역 내로 다수의 쓰레드가 진입하는 것을 막을 수 있는지 검사해야 함.
### 공정성 (fairness)
- 여러 쓰레드들이 락을 번갈아가면서 획득할 수 있어야 함.
- 락을 전혀 얻지 못해 굶주리는 경우가 발생하면 안 됨.
### 성능 (performance)
- 락 사용에 대한 시간적 오버헤드를 평가해야 한다.
- 하나의 쓰레드가 실행 중에 락을 획득하고 해제하는 과정에서 발생하는 부하가 얼마나 되는가?

## 5. 인터럽트 제어

**초창기 단일 프로세서 시스템**에서는 상호 배제 지원을 위해 임계 영역 내에서 인터럽트를 비활성화 하는 방법을 사용했다.

```c
void lock() {
	DisableInterrupts();
}
void unlock() {
	EnableInterrupts();
}
```

이 방법의 장점은 단순하다는 것이고, 단점은 많다.

1. 먼저, 이 요청을 하는 쓰레드가 인터럽트를 활성화/비활성화 하는 커널 모드 특권 연산을 실행할 수 있도록 허가해야 한다. 만약 어떤 프로그램이 시작과 동시에 `lock()`을 호출하고 무한 반복문에 들어간다면, 운영체제는 시스템의 제어권을 다시 얻을 수 없다.
2. 또, 멀티프로세서에서는 적용을 할 수 없다. 여러 쓰레드가 여러 CPU에서 실행 중이라면, 각 쓰레드가 동일한 임계 영역에 진입하려고 할 수 있다. 이 떄 인터럽트를 비활성화하는 것은 다른 프로세서에서 실행중인 프로그램에는 전혀 영향을 주지 않는다. 즉, 임계 영역에 진입하는 것을 막을 수 없다.
3. 장시간 인터럽트를 중지시키는 것은 중요한 인터럽트 시점을 놓치게 할 수 있다. CPU가 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나갔다고 해보자. 운영체제는 읽기 결과를 기다리는 프로세스를 깨울 수 없을 것이다. 
4. 마지막으로, 비효율적이다. 일반적인 명령어에 비해 인터럽트를 비활성화시키는 코드들은 최신 CPU에서는 느리게 실행된다.

따라서, 인터럽트 비활성화는 제한된 범위에서만 사용되어야 한다. 예를 들어, 운영체제가 내부 자료 구조에 atomic 연산을 하기 위해 등등..

## 6. Test-And-Set (Atomic Exchange)

멀티 프로세서 시스템에서는 인터럽트를 중지시키는 것이 의미가 없기 때문에 시스템 설계자들은 락 지원을 위한 하드웨어를 설계하기 시작했다. 오늘날에는 모든 시스템이 이러한 지원 기능을 가지고 있다.

하드웨어 기법 중 가장 기본은 ***Test-And-Set*** 명령어 또는 ***원자적 교체 (atomic exchange)*** 라고 불리는 기법이다. 

```c
typedef struct _ _lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
	// 0: 락 사용 가능
	// 1: 락 사용 중
	mutex−>flag = 0;
}

void lock(lock_t *mutex) {
	while (mutex−>flag == 1) // flag 변수를 검사 (test) 한다
	; // spin−wait (do nothing)
	mutex−>flag = 1; // 이제 설정 (set) 한다
}

void unlock(lock_t *mutex) {
	mutex−>flag = 0;
}
```










뜬금없지만 책 추천
[동시성 프로그래밍 - Rust, C, 어셈블리어로 구현하며 배우는 동시성 프로그래밍 A to Z](https://www.aladin.co.kr/m/mproduct.aspx?ItemId=291746395)
